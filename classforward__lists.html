<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>forward_list: forward_lists&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">forward_list
   </div>
   <div id="projectbrief">build forward list stl from sratch</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classforward__lists.html','','classforward__lists-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">forward_lists&lt; T, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="forward__list_8hpp_source.html">forward_list.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Node" id="r_Node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structforward__lists_1_1Node.html">Node</a></td></tr>
<tr class="memitem:Iterator" id="r_Iterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea2e770966661ed41eda597960ecda8a" id="r_aea2e770966661ed41eda597960ecda8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea2e770966661ed41eda597960ecda8a">forward_lists</a> ()</td></tr>
<tr class="memitem:aa1863de5cbc541f16d3182bd237b1a23" id="r_aa1863de5cbc541f16d3182bd237b1a23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1863de5cbc541f16d3182bd237b1a23">forward_lists</a> (const Allocator &amp;a)</td></tr>
<tr class="memitem:a0d0dc7ee20cc14793f44da963dbcaec1" id="r_a0d0dc7ee20cc14793f44da963dbcaec1"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; <br />
requires <a class="el" href="conceptmy__input__iterator.html">my_input_iterator</a>&lt;It&gt;</td></tr>
<tr class="memitem:a0d0dc7ee20cc14793f44da963dbcaec1 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d0dc7ee20cc14793f44da963dbcaec1">forward_lists</a> (It <a class="el" href="#abf7500ebb0eed63889e3ea7c86cb1407">begin</a>, It <a class="el" href="#a2961f9f4d060b819b015162e91ff1c2b">end</a>)</td></tr>
<tr class="memdesc:a0d0dc7ee20cc14793f44da963dbcaec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor range,adalah constructor yang menginialisasi nilai dari sebuah container dengan element dari suatu rentang yang di tentukan oleh 2 iterator awal(first) dan akhir(last)  <br /></td></tr>
<tr class="memitem:a80171e90c043ab549ab66d5ed74a4801" id="r_a80171e90c043ab549ab66d5ed74a4801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80171e90c043ab549ab66d5ed74a4801">forward_lists</a> (std::initializer_list&lt; T &gt; arr)</td></tr>
<tr class="memdesc:a80171e90c043ab549ab66d5ed74a4801"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializer list constructor  <br /></td></tr>
<tr class="memitem:ad4055d0278f1808b0c7d8f621151bae4" id="r_ad4055d0278f1808b0c7d8f621151bae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4055d0278f1808b0c7d8f621151bae4">forward_lists</a> (const <a class="el" href="classforward__lists.html">forward_lists</a> &amp;others)</td></tr>
<tr class="memitem:a838660b60ee44d87a9aa4c3061258161" id="r_a838660b60ee44d87a9aa4c3061258161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists.html">forward_lists</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838660b60ee44d87a9aa4c3061258161">operator=</a> (const <a class="el" href="classforward__lists.html">forward_lists</a> &amp;others)</td></tr>
<tr class="memitem:abce8ba003e99d632bf60ef77028ae576" id="r_abce8ba003e99d632bf60ef77028ae576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce8ba003e99d632bf60ef77028ae576">forward_lists</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others) noexcept</td></tr>
<tr class="memdesc:abce8ba003e99d632bf60ef77028ae576"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor dipakai ketika ingin memindahkan node pada list a ke list b  <br /></td></tr>
<tr class="memitem:ad69087950f6ae29dd5808aac53e37e94" id="r_ad69087950f6ae29dd5808aac53e37e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists.html">forward_lists</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad69087950f6ae29dd5808aac53e37e94">operator=</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others) noexcept</td></tr>
<tr class="memdesc:ad69087950f6ae29dd5808aac53e37e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment constructor  <br /></td></tr>
<tr class="memitem:a4363dbde072188462fd11edd3b44043d" id="r_a4363dbde072188462fd11edd3b44043d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4363dbde072188462fd11edd3b44043d">~forward_lists</a> ()</td></tr>
<tr class="memdesc:a4363dbde072188462fd11edd3b44043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <br /></td></tr>
<tr class="memitem:a8ff8f00251f5039003aa83daae747ff3" id="r_a8ff8f00251f5039003aa83daae747ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ff8f00251f5039003aa83daae747ff3">before_begin</a> ()</td></tr>
<tr class="memdesc:a8ff8f00251f5039003aa83daae747ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator yang menunjuk dummy node yaitu head  <br /></td></tr>
<tr class="memitem:abf7500ebb0eed63889e3ea7c86cb1407" id="r_abf7500ebb0eed63889e3ea7c86cb1407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7500ebb0eed63889e3ea7c86cb1407">begin</a> ()</td></tr>
<tr class="memdesc:abf7500ebb0eed63889e3ea7c86cb1407"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator yang menunjuk node pada element pertama pada list  <br /></td></tr>
<tr class="memitem:a2961f9f4d060b819b015162e91ff1c2b" id="r_a2961f9f4d060b819b015162e91ff1c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2961f9f4d060b819b015162e91ff1c2b">end</a> ()</td></tr>
<tr class="memdesc:a2961f9f4d060b819b015162e91ff1c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator yang menunjuk pointer setelah node terakhir(tail)  <br /></td></tr>
<tr class="memitem:aed36b057035c80dacd8a9430947dd927" id="r_aed36b057035c80dacd8a9430947dd927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed36b057035c80dacd8a9430947dd927">cbegin</a> () const</td></tr>
<tr class="memitem:ae104d0880bebf7f132dfb9b57eef5655" id="r_ae104d0880bebf7f132dfb9b57eef5655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae104d0880bebf7f132dfb9b57eef5655">cend</a> () const</td></tr>
<tr class="memitem:a55e6ad69258c0cfd35bd4a17795b8407" id="r_a55e6ad69258c0cfd35bd4a17795b8407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55e6ad69258c0cfd35bd4a17795b8407">cbefore_begin</a> () const</td></tr>
<tr class="memitem:a6f26d3529ddeb7d3aa24508a1d2b6c40" id="r_a6f26d3529ddeb7d3aa24508a1d2b6c40"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f26d3529ddeb7d3aa24508a1d2b6c40">front</a> ()</td></tr>
<tr class="memdesc:a6f26d3529ddeb7d3aa24508a1d2b6c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">method getter yang mengembalikan nilai node pada pos front  <br /></td></tr>
<tr class="memitem:aba7ef93080f6683ca8ed00c9e460fece" id="r_aba7ef93080f6683ca8ed00c9e460fece"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba7ef93080f6683ca8ed00c9e460fece">get_size</a> ()</td></tr>
<tr class="memdesc:aba7ef93080f6683ca8ed00c9e460fece"><td class="mdescLeft">&#160;</td><td class="mdescRight">method getter yang mengembalilkan jumlah element saat ini  <br /></td></tr>
<tr class="memitem:ad4c2d182c92d9ef1c640c676a8e9b69f" id="r_ad4c2d182c92d9ef1c640c676a8e9b69f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4c2d182c92d9ef1c640c676a8e9b69f">is_empty</a> ()</td></tr>
<tr class="memdesc:ad4c2d182c92d9ef1c640c676a8e9b69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">method getter yang mengembalilkan true jika list empty,sebalik false jika tidak kosong  <br /></td></tr>
<tr class="memitem:abac7bfa1262ad2a1df4b6f211468a798" id="r_abac7bfa1262ad2a1df4b6f211468a798"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac7bfa1262ad2a1df4b6f211468a798">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:abac7bfa1262ad2a1df4b6f211468a798"><td class="mdescLeft">&#160;</td><td class="mdescRight">mengembalikan jumlah maksimum yang dapat di tampung list  <br /></td></tr>
<tr class="memitem:a5b7c7c05bd8e6accc336e89da819bb01" id="r_a5b7c7c05bd8e6accc336e89da819bb01"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b7c7c05bd8e6accc336e89da819bb01">back</a> () const noexcept</td></tr>
<tr class="memitem:a19c5bd9f5df18877999d4bcc062f2459" id="r_a19c5bd9f5df18877999d4bcc062f2459"><td class="memItemLeft" align="right" valign="top">Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19c5bd9f5df18877999d4bcc062f2459">get_allocator</a> () const noexcept</td></tr>
<tr class="memitem:a1ad732c43efa45115410798e3fa8930d" id="r_a1ad732c43efa45115410798e3fa8930d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ad732c43efa45115410798e3fa8930d">check_cycle</a> () const noexcept</td></tr>
<tr class="memitem:ac9cc742e2e4c1cdc5434d91ae952aa4c" id="r_ac9cc742e2e4c1cdc5434d91ae952aa4c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9cc742e2e4c1cdc5434d91ae952aa4c">get_middle</a> () const noexcept</td></tr>
<tr class="memitem:a2d73029a03f0da14ac2d90400aa43597" id="r_a2d73029a03f0da14ac2d90400aa43597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d73029a03f0da14ac2d90400aa43597">push_front</a> (T &amp;&amp;data)</td></tr>
<tr class="memdesc:a2d73029a03f0da14ac2d90400aa43597"><td class="mdescLeft">&#160;</td><td class="mdescRight">method untuk insertion val pada pos front  <br /></td></tr>
<tr class="memitem:a4fad00bbc80dfdbb606fd234616012d0" id="r_a4fad00bbc80dfdbb606fd234616012d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fad00bbc80dfdbb606fd234616012d0">push_front</a> (const T &amp;data)</td></tr>
<tr class="memitem:a345e09a8d6da8b0d35e21e2310155776" id="r_a345e09a8d6da8b0d35e21e2310155776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a345e09a8d6da8b0d35e21e2310155776">pop_front</a> ()</td></tr>
<tr class="memdesc:a345e09a8d6da8b0d35e21e2310155776"><td class="mdescLeft">&#160;</td><td class="mdescRight">method untuk deletion val pada pos front  <br /></td></tr>
<tr class="memitem:a7dea953d9dccb65c4bf7194ba7cb3f17" id="r_a7dea953d9dccb65c4bf7194ba7cb3f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dea953d9dccb65c4bf7194ba7cb3f17">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a7dea953d9dccb65c4bf7194ba7cb3f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">adalah method untuk melakukan insertion dari posisi belakang(tail)  <br /></td></tr>
<tr class="memitem:a573d97a5140946da88fc8add02850f83" id="r_a573d97a5140946da88fc8add02850f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573d97a5140946da88fc8add02850f83">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memitem:ac35b4c372dde1087d1faac0d112be42f" id="r_ac35b4c372dde1087d1faac0d112be42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac35b4c372dde1087d1faac0d112be42f">pop_back</a> ()</td></tr>
<tr class="memdesc:ac35b4c372dde1087d1faac0d112be42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop_back adalah method untuk deletion node di posisi tail  <br /></td></tr>
<tr class="memitem:acb9b63e0a6f1c8b0c57734cdea9b8565" id="r_acb9b63e0a6f1c8b0c57734cdea9b8565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb9b63e0a6f1c8b0c57734cdea9b8565">insert_after</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> iter_position, T &amp;&amp;val)</td></tr>
<tr class="memdesc:acb9b63e0a6f1c8b0c57734cdea9b8565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Menyisipkan elemen setelah posisi iterator tertentu.  <br /></td></tr>
<tr class="memitem:a6d10e85cfabe7d7246f785ce85c6d51e" id="r_a6d10e85cfabe7d7246f785ce85c6d51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d10e85cfabe7d7246f785ce85c6d51e">insert_after</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> iter_position, const T &amp;val)</td></tr>
<tr class="memitem:a821f2f9f7eeeed80c7b0d23b31d1a0bd" id="r_a821f2f9f7eeeed80c7b0d23b31d1a0bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a821f2f9f7eeeed80c7b0d23b31d1a0bd">insert_after</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> Iterator_position, int n, T &amp;&amp;val)</td></tr>
<tr class="memitem:a73140b4bd7262280e3d5ec22592b58cc" id="r_a73140b4bd7262280e3d5ec22592b58cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73140b4bd7262280e3d5ec22592b58cc">insert_after</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> Iterator_position, int n, const T &amp;val)</td></tr>
<tr class="memitem:ab0990856e79c2984276f5857319d6c7b" id="r_ab0990856e79c2984276f5857319d6c7b"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator It&gt; <br />
requires (!std::same_as&lt;It,<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&gt;)</td></tr>
<tr class="memitem:ab0990856e79c2984276f5857319d6c7b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0990856e79c2984276f5857319d6c7b">insert_after</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> iter_position, It itr1, It itr2)</td></tr>
<tr class="memitem:ab41b0227bb2448741edba86b90ab3721" id="r_ab41b0227bb2448741edba86b90ab3721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab41b0227bb2448741edba86b90ab3721">insert_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> iter_position, <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> listBegin, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> listEnd)</td></tr>
<tr class="memitem:a8c3256e5e289927f5b034e75b7ad9e49" id="r_a8c3256e5e289927f5b034e75b7ad9e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c3256e5e289927f5b034e75b7ad9e49">erase_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> iter_position)</td></tr>
<tr class="memitem:a8caf87ded904cac3b08681d263250d88" id="r_a8caf87ded904cac3b08681d263250d88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8caf87ded904cac3b08681d263250d88">erase_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos_begin, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos_end)</td></tr>
<tr class="memitem:a8531c2829b5ba52d436338be3d50916e" id="r_a8531c2829b5ba52d436338be3d50916e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8531c2829b5ba52d436338be3d50916e">reverse</a> ()</td></tr>
<tr class="memitem:afee6ca82d6ce6d7637ab8cf87bdbf312" id="r_afee6ca82d6ce6d7637ab8cf87bdbf312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afee6ca82d6ce6d7637ab8cf87bdbf312">assign</a> (std::size_t n, const T &amp;value)</td></tr>
<tr class="memdesc:afee6ca82d6ce6d7637ab8cf87bdbf312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method Assign Assign dipakai untuk mereplace list saat ini dengan list baru overload method assign assign(n,value) -&gt;insert value sebanyak n kali assign(initializer_list&lt;T&gt;)-&gt;replace value pada initializer list ke list saat ini assign(iterator begin,iterator end) -&gt;replace mulai dari iterator begin sampai sebelum iterator end.  <br /></td></tr>
<tr class="memitem:a6a3a3856474a46c7c656d6e68a1b2d6d" id="r_a6a3a3856474a46c7c656d6e68a1b2d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3a3856474a46c7c656d6e68a1b2d6d">assign</a> (std::size_t n, T &amp;&amp;value)</td></tr>
<tr class="memitem:a63f5e770292393adfe1c69097716c84b" id="r_a63f5e770292393adfe1c69097716c84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63f5e770292393adfe1c69097716c84b">assign</a> (std::initializer_list&lt; T &gt; arr)</td></tr>
<tr class="memitem:a4c0258897f6de0ec5f614512a528c93f" id="r_a4c0258897f6de0ec5f614512a528c93f"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; <br />
requires <a class="el" href="conceptmy__input__iterator.html">my_input_iterator</a>&lt;It&gt;</td></tr>
<tr class="memitem:a4c0258897f6de0ec5f614512a528c93f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c0258897f6de0ec5f614512a528c93f">assign</a> (It itr1, It itr2)</td></tr>
<tr class="memitem:a4dfa0841b588e073883f6ce046502986" id="r_a4dfa0841b588e073883f6ce046502986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dfa0841b588e073883f6ce046502986">splice_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, <a class="el" href="classforward__lists.html">forward_lists</a> &amp;others, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> It)</td></tr>
<tr class="memdesc:a4dfa0841b588e073883f6ce046502986"><td class="mdescLeft">&#160;</td><td class="mdescRight">slice after method untuk memindahkan node dari satu list ke list lain tanpa menyalin data,tetapi move node pointer  <br /></td></tr>
<tr class="memitem:a9686749a1d12fdb9d4e39cb8fd852ffe" id="r_a9686749a1d12fdb9d4e39cb8fd852ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9686749a1d12fdb9d4e39cb8fd852ffe">splice_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, <a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> It)</td></tr>
<tr class="memitem:af47f75700dd28948192e16895bb5d7b8" id="r_af47f75700dd28948192e16895bb5d7b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af47f75700dd28948192e16895bb5d7b8">splice_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, <a class="el" href="classforward__lists.html">forward_lists</a> &amp;others)</td></tr>
<tr class="memitem:a75061e69811c122993e15dab0d2521e4" id="r_a75061e69811c122993e15dab0d2521e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75061e69811c122993e15dab0d2521e4">splice_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, <a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others)</td></tr>
<tr class="memitem:a4b8b4f9f90f2f91fa3995fe038e70aaa" id="r_a4b8b4f9f90f2f91fa3995fe038e70aaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8b4f9f90f2f91fa3995fe038e70aaa">splice_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, <a class="el" href="classforward__lists.html">forward_lists</a> &amp;others, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> first, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> last)</td></tr>
<tr class="memitem:aa45fb3ab2dfe2e3ddfd8322f994ed6bc" id="r_aa45fb3ab2dfe2e3ddfd8322f994ed6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa45fb3ab2dfe2e3ddfd8322f994ed6bc">splice_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, <a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> first, const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> last)</td></tr>
<tr class="memitem:ad9c9859a30eba9eff0a6c20bcb662093" id="r_ad9c9859a30eba9eff0a6c20bcb662093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c9859a30eba9eff0a6c20bcb662093">swap</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;others) noexcept</td></tr>
<tr class="memitem:ae81c81d81520179d53979e2c2e17b311" id="r_ae81c81d81520179d53979e2c2e17b311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae81c81d81520179d53979e2c2e17b311">swap</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others) noexcept</td></tr>
<tr class="memitem:a2f15bca63d3b2ba4d269abab2f94f9b7" id="r_a2f15bca63d3b2ba4d269abab2f94f9b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f15bca63d3b2ba4d269abab2f94f9b7">sort</a> ()</td></tr>
<tr class="memitem:aa274e7835e1e4020a803783d7ec1dbc3" id="r_aa274e7835e1e4020a803783d7ec1dbc3"><td class="memTemplParams" colspan="2">template&lt;typename Compare = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa274e7835e1e4020a803783d7ec1dbc3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa274e7835e1e4020a803783d7ec1dbc3">sort</a> (Compare comp=Compare{})</td></tr>
<tr class="memitem:a8ddf695b1f0af76204cb8f362e492450" id="r_a8ddf695b1f0af76204cb8f362e492450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ddf695b1f0af76204cb8f362e492450">merge</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;others)</td></tr>
<tr class="memitem:a85866ff9f6a7a76261d735387420b887" id="r_a85866ff9f6a7a76261d735387420b887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85866ff9f6a7a76261d735387420b887">merge</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others)</td></tr>
<tr class="memitem:a2f09bf77c228c55bd9587348f8a89c7f" id="r_a2f09bf77c228c55bd9587348f8a89c7f"><td class="memTemplParams" colspan="2">template&lt;typename compare = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a2f09bf77c228c55bd9587348f8a89c7f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f09bf77c228c55bd9587348f8a89c7f">merge</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;others, compare comp=compare{})</td></tr>
<tr class="memitem:aec014a02a59d54633eb136bb59a70646" id="r_aec014a02a59d54633eb136bb59a70646"><td class="memTemplParams" colspan="2">template&lt;typename compare = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aec014a02a59d54633eb136bb59a70646 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec014a02a59d54633eb136bb59a70646">merge</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others, compare comp=compare{})</td></tr>
<tr class="memitem:a9b1fdd0820f7812c3230dcb9345f7a29" id="r_a9b1fdd0820f7812c3230dcb9345f7a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b1fdd0820f7812c3230dcb9345f7a29">merge_sort</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;others)</td></tr>
<tr class="memitem:a8bc075dd0125e957b5f0a748acd1c0a2" id="r_a8bc075dd0125e957b5f0a748acd1c0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bc075dd0125e957b5f0a748acd1c0a2">merge_sort</a> (<a class="el" href="classforward__lists.html">forward_lists</a> &amp;&amp;others)</td></tr>
<tr class="memitem:ae4fc2304c3059c1d838b94a73c6110e2" id="r_ae4fc2304c3059c1d838b94a73c6110e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4fc2304c3059c1d838b94a73c6110e2">resize</a> (std::size_t count)</td></tr>
<tr class="memdesc:ae4fc2304c3059c1d838b94a73c6110e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize adalah method untuk mengubah ukuran sebuah list  <br /></td></tr>
<tr class="memitem:a4bfc7c2e1150d78b63663a2f7568032d" id="r_a4bfc7c2e1150d78b63663a2f7568032d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfc7c2e1150d78b63663a2f7568032d">resize</a> (std::size_t count, const T &amp;value)</td></tr>
<tr class="memitem:ae7bf2b62a9f566aa71031bb4b7aa82c6" id="r_ae7bf2b62a9f566aa71031bb4b7aa82c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7bf2b62a9f566aa71031bb4b7aa82c6">uniqe_all</a> ()</td></tr>
<tr class="memitem:a42ca065a6ce2d83adb5d20fa72f78530" id="r_a42ca065a6ce2d83adb5d20fa72f78530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ca065a6ce2d83adb5d20fa72f78530">uniqe</a> ()</td></tr>
<tr class="memitem:a96e7408f417facee13e879bccd03e985" id="r_a96e7408f417facee13e879bccd03e985"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:a96e7408f417facee13e879bccd03e985 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96e7408f417facee13e879bccd03e985">assign_range</a> (R &amp;&amp;rg)</td></tr>
<tr class="memitem:ac979fe598f3abc38dcf601041950dc36" id="r_ac979fe598f3abc38dcf601041950dc36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac979fe598f3abc38dcf601041950dc36">assign_range</a> (std::initializer_list&lt; T &gt; arr)</td></tr>
<tr class="memitem:aed969f13634751e244f9d307072dafeb" id="r_aed969f13634751e244f9d307072dafeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed969f13634751e244f9d307072dafeb">remove</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aed969f13634751e244f9d307072dafeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload remove untuk menghapus node dengan nilai sama dengan parameter value  <br /></td></tr>
<tr class="memitem:a9bb151680f26183d69901a068be5fea2" id="r_a9bb151680f26183d69901a068be5fea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb151680f26183d69901a068be5fea2">remove</a> (const std::size_t pos)</td></tr>
<tr class="memdesc:a9bb151680f26183d69901a068be5fea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">method overload remove,untuk menghapus node pada posisi pos  <br /></td></tr>
<tr class="memitem:a8bd7863cc50185b95db693d1ba6fd75d" id="r_a8bd7863cc50185b95db693d1ba6fd75d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bd7863cc50185b95db693d1ba6fd75d">remove_count</a> (const T &amp;value)</td></tr>
<tr class="memitem:ad226ed7b442c787418eba74c5a661d4e" id="r_ad226ed7b442c787418eba74c5a661d4e"><td class="memTemplParams" colspan="2">template&lt;class UnaryPred&gt; <br />
requires (std::predicate&lt;UnaryPred&amp;, const T&amp;&gt;)</td></tr>
<tr class="memitem:ad226ed7b442c787418eba74c5a661d4e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad226ed7b442c787418eba74c5a661d4e">remove_if</a> (UnaryPred p)</td></tr>
<tr class="memitem:a4fedd388ecf4ee573e67ec914b2d6f10" id="r_a4fedd388ecf4ee573e67ec914b2d6f10"><td class="memTemplParams" colspan="2">template&lt;class UnaryPred&gt; <br />
requires (std::predicate&lt;UnaryPred&amp;,const T&amp;&gt;)</td></tr>
<tr class="memitem:a4fedd388ecf4ee573e67ec914b2d6f10 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fedd388ecf4ee573e67ec914b2d6f10">remove_if_count</a> (UnaryPred p)</td></tr>
<tr class="memitem:a70a522c91007772dada1b9f6976db62b" id="r_a70a522c91007772dada1b9f6976db62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70a522c91007772dada1b9f6976db62b">print_all</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="#abf7500ebb0eed63889e3ea7c86cb1407">begin</a>, <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="#a2961f9f4d060b819b015162e91ff1c2b">end</a>)</td></tr>
<tr class="memdesc:a70a522c91007772dada1b9f6976db62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">method untuk print semua node list  <br /></td></tr>
<tr class="memitem:ae7938bb6fa3b42eb8bffd1dc76d43fad" id="r_ae7938bb6fa3b42eb8bffd1dc76d43fad"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:ae7938bb6fa3b42eb8bffd1dc76d43fad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7938bb6fa3b42eb8bffd1dc76d43fad">insert_range_after</a> (const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> &amp;pos, R &amp;&amp;r)</td></tr>
<tr class="memdesc:ae7938bb6fa3b42eb8bffd1dc76d43fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">method untuk menghapus semua node pada head berguna pada destructor  <br /></td></tr>
<tr class="memitem:aa684b6f9494a2bc6aea68e6f9c779b0d" id="r_aa684b6f9494a2bc6aea68e6f9c779b0d"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:aa684b6f9494a2bc6aea68e6f9c779b0d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa684b6f9494a2bc6aea68e6f9c779b0d">prepend_range</a> (R &amp;&amp;r)</td></tr>
<tr class="memitem:a4a55c9c332d65b3a63571cc4d9cc480c" id="r_a4a55c9c332d65b3a63571cc4d9cc480c"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a4a55c9c332d65b3a63571cc4d9cc480c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a55c9c332d65b3a63571cc4d9cc480c">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memitem:af723aa81dfce2c927d5fc534ffb6da48" id="r_af723aa81dfce2c927d5fc534ffb6da48"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:af723aa81dfce2c927d5fc534ffb6da48 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af723aa81dfce2c927d5fc534ffb6da48">emplace_after</a> (<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memitem:a66b4a59e7ec6a4cda9055b8422b31e66" id="r_a66b4a59e7ec6a4cda9055b8422b31e66"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a66b4a59e7ec6a4cda9055b8422b31e66 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b4a59e7ec6a4cda9055b8422b31e66">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memitem:a260090b662de81e4f506121781fbc90f" id="r_a260090b662de81e4f506121781fbc90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a260090b662de81e4f506121781fbc90f">clear</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-types" class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a4b8ffb5a9805204d6b06324dd7151990" id="r_a4b8ffb5a9805204d6b06324dd7151990"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8ffb5a9805204d6b06324dd7151990">node_allocator_type</a></td></tr>
<tr class="memitem:a971ba6a67fa9ce71a9a07fcc18205833" id="r_a971ba6a67fa9ce71a9a07fcc18205833"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a971ba6a67fa9ce71a9a07fcc18205833">node_traits</a> = std::allocator_traits&lt;<a class="el" href="#a4b8ffb5a9805204d6b06324dd7151990">node_allocator_type</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-methods" class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8bb26e758f7b84911f4837a46dbf1331" id="r_a8bb26e758f7b84911f4837a46dbf1331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb26e758f7b84911f4837a46dbf1331">_create_node</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a8bb26e758f7b84911f4837a46dbf1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator explanation Allocator adalah abstraksi cara mengelola memory pada container alih2 melakukan new dan delete,STL memakai allocator yaitu semacam policy class yang akan menentukan: 1.bagaimana alokasi memory dilakukan(allocate) 2.bagaimana membangun object di memori(construct) 3.bagaimana menghancurkan object(destroy) 4.bagaimana membebaskan memory(deallocate).  <br /></td></tr>
<tr class="memitem:a8b591c0b30fd2182bed24ec9257f46d4" id="r_a8b591c0b30fd2182bed24ec9257f46d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b591c0b30fd2182bed24ec9257f46d4">_destroy_node</a> (<a class="el" href="structforward__lists_1_1Node.html">Node</a> *n) noexcept</td></tr>
<tr class="memitem:a6139cf2be37d2129c8b71bd12278e10c" id="r_a6139cf2be37d2129c8b71bd12278e10c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6139cf2be37d2129c8b71bd12278e10c">merge</a> (<a class="el" href="structforward__lists_1_1Node.html">Node</a> *left, <a class="el" href="structforward__lists_1_1Node.html">Node</a> *right)</td></tr>
<tr class="memitem:a6dff547e343bd6ae536ec928504ac625" id="r_a6dff547e343bd6ae536ec928504ac625"><td class="memTemplParams" colspan="2">template&lt;typename compare = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6dff547e343bd6ae536ec928504ac625 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dff547e343bd6ae536ec928504ac625">merge</a> (<a class="el" href="structforward__lists_1_1Node.html">Node</a> *left, <a class="el" href="structforward__lists_1_1Node.html">Node</a> *right, compare comp)</td></tr>
<tr class="memitem:a70814c318e65ea78de97cdd1ed9c0e92" id="r_a70814c318e65ea78de97cdd1ed9c0e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70814c318e65ea78de97cdd1ed9c0e92">getMiddle</a> (<a class="el" href="structforward__lists_1_1Node.html">Node</a> *<a class="el" href="#a867aa7370d5822cc13138bfca6f42238">head</a>)</td></tr>
<tr class="memitem:a207335e63a6c9628602e8b548a58f039" id="r_a207335e63a6c9628602e8b548a58f039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a207335e63a6c9628602e8b548a58f039">helper</a> (<a class="el" href="structforward__lists_1_1Node.html">Node</a> *<a class="el" href="#a867aa7370d5822cc13138bfca6f42238">head</a>)</td></tr>
<tr class="memitem:af01e0d2fcdf6f33e024f4fef15f9bb2e" id="r_af01e0d2fcdf6f33e024f4fef15f9bb2e"><td class="memTemplParams" colspan="2">template&lt;typename compare&gt; </td></tr>
<tr class="memitem:af01e0d2fcdf6f33e024f4fef15f9bb2e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af01e0d2fcdf6f33e024f4fef15f9bb2e">helper</a> (<a class="el" href="structforward__lists_1_1Node.html">Node</a> *<a class="el" href="#a867aa7370d5822cc13138bfca6f42238">head</a>, compare comp)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-attribs" class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a40ee44479b2e65bc84c3d402648f788a" id="r_a40ee44479b2e65bc84c3d402648f788a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4b8ffb5a9805204d6b06324dd7151990">node_allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ee44479b2e65bc84c3d402648f788a">alloc</a></td></tr>
<tr class="memitem:a867aa7370d5822cc13138bfca6f42238" id="r_a867aa7370d5822cc13138bfca6f42238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a867aa7370d5822cc13138bfca6f42238">head</a> = nullptr</td></tr>
<tr class="memitem:a477a4d2a03ec01ffdb339c0d99c0c629" id="r_a477a4d2a03ec01ffdb339c0d99c0c629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a477a4d2a03ec01ffdb339c0d99c0c629">tail</a></td></tr>
<tr class="memitem:ab47d1cd8e4febd01feae8cb3ea5ad8bc" id="r_ab47d1cd8e4febd01feae8cb3ea5ad8bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab47d1cd8e4febd01feae8cb3ea5ad8bc">size</a></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a4b8ffb5a9805204d6b06324dd7151990" name="a4b8ffb5a9805204d6b06324dd7151990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8ffb5a9805204d6b06324dd7151990">&#9670;&#160;</a></span>node_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::node_allocator_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        <span class="keyword">typename</span> std::allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;Node&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a971ba6a67fa9ce71a9a07fcc18205833" name="a971ba6a67fa9ce71a9a07fcc18205833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971ba6a67fa9ce71a9a07fcc18205833">&#9670;&#160;</a></span>node_traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::node_traits = std::allocator_traits&lt;<a class="el" href="#a4b8ffb5a9805204d6b06324dd7151990">node_allocator_type</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea2e770966661ed41eda597960ecda8a" name="aea2e770966661ed41eda597960ecda8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2e770966661ed41eda597960ecda8a">&#9670;&#160;</a></span>forward_lists() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::forward_lists </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1863de5cbc541f16d3182bd237b1a23" name="aa1863de5cbc541f16d3182bd237b1a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1863de5cbc541f16d3182bd237b1a23">&#9670;&#160;</a></span>forward_lists() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::forward_lists </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0dc7ee20cc14793f44da963dbcaec1" name="a0d0dc7ee20cc14793f44da963dbcaec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0dc7ee20cc14793f44da963dbcaec1">&#9670;&#160;</a></span>forward_lists() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It&gt; <br />
requires <a class="el" href="conceptmy__input__iterator.html">my_input_iterator</a>&lt;It&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::forward_lists </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor range,adalah constructor yang menginialisasi nilai dari sebuah container dengan element dari suatu rentang yang di tentukan oleh 2 iterator awal(first) dan akhir(last) </p>
<p>time complexity o(n), dan space complexity O(n) </p>

</div>
</div>
<a id="a80171e90c043ab549ab66d5ed74a4801" name="a80171e90c043ab549ab66d5ed74a4801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80171e90c043ab549ab66d5ed74a4801">&#9670;&#160;</a></span>forward_lists() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::forward_lists </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initializer list constructor </p>
<p>time complexity O(n),Space Complexity O(n) </p>

</div>
</div>
<a id="ad4055d0278f1808b0c7d8f621151bae4" name="ad4055d0278f1808b0c7d8f621151bae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4055d0278f1808b0c7d8f621151bae4">&#9670;&#160;</a></span>forward_lists() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::forward_lists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abce8ba003e99d632bf60ef77028ae576" name="abce8ba003e99d632bf60ef77028ae576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce8ba003e99d632bf60ef77028ae576">&#9670;&#160;</a></span>forward_lists() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::forward_lists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor dipakai ketika ingin memindahkan node pada list a ke list b </p>
<p>others.head dipakai untuk menghindari double delete ketika others keluar dari scope function maka destructor dipanggil karena head = others.head maka head == nullptr,akan mengakibatkan undefined behavior </p>

</div>
</div>
<a id="a4363dbde072188462fd11edd3b44043d" name="a4363dbde072188462fd11edd3b44043d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4363dbde072188462fd11edd3b44043d">&#9670;&#160;</a></span>~forward_lists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::~<a class="el" href="classforward__lists.html">forward_lists</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<ul>
<li>panggil method clear head harus tetap menunjuk dummy node </li>
</ul>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8bb26e758f7b84911f4837a46dbf1331" name="a8bb26e758f7b84911f4837a46dbf1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb26e758f7b84911f4837a46dbf1331">&#9670;&#160;</a></span>_create_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a> * <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::_create_node </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator explanation Allocator adalah abstraksi cara mengelola memory pada container alih2 melakukan new dan delete,STL memakai allocator yaitu semacam policy class yang akan menentukan: 1.bagaimana alokasi memory dilakukan(allocate) 2.bagaimana membangun object di memori(construct) 3.bagaimana menghancurkan object(destroy) 4.bagaimana membebaskan memory(deallocate). </p>
<p>policy class Policy class adalah konsep desain di C++ di mana sebuah class tidak menentukan perilaku sendiri, tapi mendelegasikan perilaku tertentu ke class lain </p>

</div>
</div>
<a id="a8b591c0b30fd2182bed24ec9257f46d4" name="a8b591c0b30fd2182bed24ec9257f46d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b591c0b30fd2182bed24ec9257f46d4">&#9670;&#160;</a></span>_destroy_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::_destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c0258897f6de0ec5f614512a528c93f" name="a4c0258897f6de0ec5f614512a528c93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0258897f6de0ec5f614512a528c93f">&#9670;&#160;</a></span>assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It&gt; <br />
requires <a class="el" href="conceptmy__input__iterator.html">my_input_iterator</a>&lt;It&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itr2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63f5e770292393adfe1c69097716c84b" name="a63f5e770292393adfe1c69097716c84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f5e770292393adfe1c69097716c84b">&#9670;&#160;</a></span>assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afee6ca82d6ce6d7637ab8cf87bdbf312" name="afee6ca82d6ce6d7637ab8cf87bdbf312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee6ca82d6ce6d7637ab8cf87bdbf312">&#9670;&#160;</a></span>assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method Assign Assign dipakai untuk mereplace list saat ini dengan list baru overload method assign assign(n,value) -&gt;insert value sebanyak n kali assign(initializer_list&lt;T&gt;)-&gt;replace value pada initializer list ke list saat ini assign(iterator begin,iterator end) -&gt;replace mulai dari iterator begin sampai sebelum iterator end. </p>
<p>Time complexity O(n),Space Complexity O(n) </p>

</div>
</div>
<a id="a6a3a3856474a46c7c656d6e68a1b2d6d" name="a6a3a3856474a46c7c656d6e68a1b2d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3a3856474a46c7c656d6e68a1b2d6d">&#9670;&#160;</a></span>assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96e7408f417facee13e879bccd03e985" name="a96e7408f417facee13e879bccd03e985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e7408f417facee13e879bccd03e985">&#9670;&#160;</a></span>assign_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::assign_range </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac979fe598f3abc38dcf601041950dc36" name="ac979fe598f3abc38dcf601041950dc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac979fe598f3abc38dcf601041950dc36">&#9670;&#160;</a></span>assign_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::assign_range </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b7c7c05bd8e6accc336e89da819bb01" name="a5b7c7c05bd8e6accc336e89da819bb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7c7c05bd8e6accc336e89da819bb01">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff8f00251f5039003aa83daae747ff3" name="a8ff8f00251f5039003aa83daae747ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff8f00251f5039003aa83daae747ff3">&#9670;&#160;</a></span>before_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::before_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterator yang menunjuk dummy node yaitu head </p>

</div>
</div>
<a id="abf7500ebb0eed63889e3ea7c86cb1407" name="abf7500ebb0eed63889e3ea7c86cb1407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7500ebb0eed63889e3ea7c86cb1407">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterator yang menunjuk node pada element pertama pada list </p>

</div>
</div>
<a id="a55e6ad69258c0cfd35bd4a17795b8407" name="a55e6ad69258c0cfd35bd4a17795b8407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e6ad69258c0cfd35bd4a17795b8407">&#9670;&#160;</a></span>cbefore_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::cbefore_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed36b057035c80dacd8a9430947dd927" name="aed36b057035c80dacd8a9430947dd927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed36b057035c80dacd8a9430947dd927">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae104d0880bebf7f132dfb9b57eef5655" name="ae104d0880bebf7f132dfb9b57eef5655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae104d0880bebf7f132dfb9b57eef5655">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ad732c43efa45115410798e3fa8930d" name="a1ad732c43efa45115410798e3fa8930d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad732c43efa45115410798e3fa8930d">&#9670;&#160;</a></span>check_cycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::check_cycle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a260090b662de81e4f506121781fbc90f" name="a260090b662de81e4f506121781fbc90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260090b662de81e4f506121781fbc90f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af723aa81dfce2c927d5fc534ffb6da48" name="af723aa81dfce2c927d5fc534ffb6da48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af723aa81dfce2c927d5fc534ffb6da48">&#9670;&#160;</a></span>emplace_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::emplace_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b4a59e7ec6a4cda9055b8422b31e66" name="a66b4a59e7ec6a4cda9055b8422b31e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4a59e7ec6a4cda9055b8422b31e66">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a55c9c332d65b3a63571cc4d9cc480c" name="a4a55c9c332d65b3a63571cc4d9cc480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a55c9c332d65b3a63571cc4d9cc480c">&#9670;&#160;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2961f9f4d060b819b015162e91ff1c2b" name="a2961f9f4d060b819b015162e91ff1c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2961f9f4d060b819b015162e91ff1c2b">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterator yang menunjuk pointer setelah node terakhir(tail) </p>

</div>
</div>
<a id="a8c3256e5e289927f5b034e75b7ad9e49" name="a8c3256e5e289927f5b034e75b7ad9e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3256e5e289927f5b034e75b7ad9e49">&#9670;&#160;</a></span>erase_after() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter_position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8caf87ded904cac3b08681d263250d88" name="a8caf87ded904cac3b08681d263250d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8caf87ded904cac3b08681d263250d88">&#9670;&#160;</a></span>erase_after() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos_begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f26d3529ddeb7d3aa24508a1d2b6c40" name="a6f26d3529ddeb7d3aa24508a1d2b6c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f26d3529ddeb7d3aa24508a1d2b6c40">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method getter yang mengembalikan nilai node pada pos front </p>
<p>time complexity O(1) </p>

</div>
</div>
<a id="a19c5bd9f5df18877999d4bcc062f2459" name="a19c5bd9f5df18877999d4bcc062f2459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c5bd9f5df18877999d4bcc062f2459">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Allocator <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9cc742e2e4c1cdc5434d91ae952aa4c" name="ac9cc742e2e4c1cdc5434d91ae952aa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cc742e2e4c1cdc5434d91ae952aa4c">&#9670;&#160;</a></span>get_middle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::get_middle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba7ef93080f6683ca8ed00c9e460fece" name="aba7ef93080f6683ca8ed00c9e460fece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7ef93080f6683ca8ed00c9e460fece">&#9670;&#160;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method getter yang mengembalilkan jumlah element saat ini </p>
<p>time complexity O(1) </p>

</div>
</div>
<a id="a70814c318e65ea78de97cdd1ed9c0e92" name="a70814c318e65ea78de97cdd1ed9c0e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70814c318e65ea78de97cdd1ed9c0e92">&#9670;&#160;</a></span>getMiddle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a> * <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::getMiddle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a207335e63a6c9628602e8b548a58f039" name="a207335e63a6c9628602e8b548a58f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207335e63a6c9628602e8b548a58f039">&#9670;&#160;</a></span>helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a> * <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af01e0d2fcdf6f33e024f4fef15f9bb2e" name="af01e0d2fcdf6f33e024f4fef15f9bb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01e0d2fcdf6f33e024f4fef15f9bb2e">&#9670;&#160;</a></span>helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a> * <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab41b0227bb2448741edba86b90ab3721" name="ab41b0227bb2448741edba86b90ab3721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41b0227bb2448741edba86b90ab3721">&#9670;&#160;</a></span>insert_after() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>listBegin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>listEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d10e85cfabe7d7246f785ce85c6d51e" name="a6d10e85cfabe7d7246f785ce85c6d51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d10e85cfabe7d7246f785ce85c6d51e">&#9670;&#160;</a></span>insert_after() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0990856e79c2984276f5857319d6c7b" name="ab0990856e79c2984276f5857319d6c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0990856e79c2984276f5857319d6c7b">&#9670;&#160;</a></span>insert_after() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator It&gt; <br />
requires (!std::same_as&lt;It,<a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itr2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb9b63e0a6f1c8b0c57734cdea9b8565" name="acb9b63e0a6f1c8b0c57734cdea9b8565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9b63e0a6f1c8b0c57734cdea9b8565">&#9670;&#160;</a></span>insert_after() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Menyisipkan elemen setelah posisi iterator tertentu. </p>
<p>Method ini memiliki beberapa bentuk (overload) untuk menyesuaikan kebutuhan:</p>
<ol type="1">
<li><span class="tt"><a class="el" href="#acb9b63e0a6f1c8b0c57734cdea9b8565" title="Menyisipkan elemen setelah posisi iterator tertentu.">insert_after</a>(iterator pos, const T&amp; value)</span> <br  />
 Menyisipkan satu elemen setelah posisi <span class="tt">pos</span>.</li>
<li><span class="tt"><a class="el" href="#acb9b63e0a6f1c8b0c57734cdea9b8565" title="Menyisipkan elemen setelah posisi iterator tertentu.">insert_after</a>(iterator pos, size_type n, const T&amp; value)</span> <br  />
 Menyisipkan <span class="tt">n</span> elemen dengan nilai <span class="tt">value</span> setelah posisi <span class="tt">pos</span>.</li>
<li><span class="tt">insert_after(iterator pos, InputIterator first, InputIterator last)</span> <br  />
 Menyisipkan elemen dari rentang <span class="tt">[first, last)</span> setelah posisi <span class="tt">pos</span>.</li>
<li><span class="tt"><a class="el" href="#acb9b63e0a6f1c8b0c57734cdea9b8565" title="Menyisipkan elemen setelah posisi iterator tertentu.">insert_after</a>(iterator pos, std::initializer_list&lt;T&gt; ilist)</span> <br  />
 Menyisipkan seluruh elemen dari <span class="tt">ilist</span> setelah posisi <span class="tt">pos</span>.</li>
</ol>
<p>Overload insert_after(iterator pos, const T&amp; value)</p>
<p>Method ini biasanya membutuhkan 2 overload function agar dapat bekerja optimal:</p>
<ol type="1">
<li>Overload dengan parameter <b>const reference</b> (<span class="tt">const T&amp;</span>): <br  />
<ul>
<li>Digunakan ketika argumen yang diberikan adalah <b>lvalue</b>. <br  />
</li>
<li>Objek tidak dipindahkan, tetapi disalin (copy). <br  />
</li>
<li>Efisien karena tidak membuat salinan tambahan saat menerima lvalue. <br  />
</li>
<li>Keterbatasan: tidak bisa langsung menerima rvalue.</li>
</ul>
</li>
<li>Overload dengan parameter <b>rvalue reference</b> (<span class="tt">T&amp;&amp;</span>) / <b>forwarding reference</b>: <br  />
<ul>
<li>Digunakan ketika argumen adalah <b>rvalue</b> atau ketika kita ingin memanfaatkan move semantics. <br  />
</li>
<li>Bisa juga menerima lvalue, karena forwarding reference tunduk pada <em>reference collapsing rules</em>. <br  />
</li>
<li>Harus dipanggil dengan <span class="tt">std::forward&lt;T&gt;(val)</span> agar semantik lvalue/rvalue tetap terjaga.</li>
</ul>
</li>
</ol>
<p>Catatan penting mengenai forwarding reference:</p><ul>
<li>Jika argumen adalah <b>lvalue</b>, maka <span class="tt">T</span> akan terdeduksi sebagai <span class="tt">T&amp;</span>, dan parameter <span class="tt">T&amp;&amp;</span> akan menjadi <span class="tt">T&amp; &amp;&amp;</span>  dikecilkan (collapse) menjadi <span class="tt">T&amp;</span>.</li>
<li>Jika argumen adalah <b>rvalue</b>, maka <span class="tt">T</span> akan terdeduksi sebagai <span class="tt">T</span>, dan parameter <span class="tt">T&amp;&amp;</span> benar-benar menjadi rvalue reference.</li>
</ul>
<p>Dengan dua overload ini:</p><ul>
<li><span class="tt">insert_after(pos, x)</span>  memanggil versi <span class="tt">const T&amp;</span> (copy dari lvalue). <br  />
</li>
<li><span class="tt">insert_after(pos, std::move(x))</span> atau <span class="tt"><a class="el" href="#acb9b63e0a6f1c8b0c57734cdea9b8565" title="Menyisipkan elemen setelah posisi iterator tertentu.">insert_after</a>(pos, T("..."))</span>  memanggil versi <span class="tt">T&amp;&amp;</span> (move dari rvalue). </li>
</ul>

</div>
</div>
<a id="a73140b4bd7262280e3d5ec22592b58cc" name="a73140b4bd7262280e3d5ec22592b58cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73140b4bd7262280e3d5ec22592b58cc">&#9670;&#160;</a></span>insert_after() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>Iterator_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a821f2f9f7eeeed80c7b0d23b31d1a0bd" name="a821f2f9f7eeeed80c7b0d23b31d1a0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821f2f9f7eeeed80c7b0d23b31d1a0bd">&#9670;&#160;</a></span>insert_after() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>Iterator_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7938bb6fa3b42eb8bffd1dc76d43fad" name="ae7938bb6fa3b42eb8bffd1dc76d43fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7938bb6fa3b42eb8bffd1dc76d43fad">&#9670;&#160;</a></span>insert_range_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::insert_range_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method untuk menghapus semua node pada head berguna pada destructor </p>
<p>time complexity O(n),Space Complexity O(n) </p>

</div>
</div>
<a id="ad4c2d182c92d9ef1c640c676a8e9b69f" name="ad4c2d182c92d9ef1c640c676a8e9b69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c2d182c92d9ef1c640c676a8e9b69f">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method getter yang mengembalilkan true jika list empty,sebalik false jika tidak kosong </p>
<p>time complexity O(1) </p>

</div>
</div>
<a id="abac7bfa1262ad2a1df4b6f211468a798" name="abac7bfa1262ad2a1df4b6f211468a798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac7bfa1262ad2a1df4b6f211468a798">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mengembalikan jumlah maksimum yang dapat di tampung list </p>
<p>konsep adalah maksimum byte element yang dapat ditampung type data dibagi oleh jumlah memory untuk 1 node satu node terdiri dari:</p><ul>
<li>data (misal int ) -&gt;4 byte</li>
<li>pointer ke node berikut nya(Node) -&gt; 8 byte pada arsitektur 64 byte jadi perhitungannya: <div class="fragment"><div class="line">std::numeric_limits&lt;size_t&gt;::max() / <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structforward__lists_1_1Node.html">Node</a>)</div>
<div class="ttc" id="astructforward__lists_1_1Node_html"><div class="ttname"><a href="structforward__lists_1_1Node.html">forward_lists::Node</a></div><div class="ttdef"><b>Definition</b> forward_list.hpp:46</div></div>
</div><!-- fragment --> Time complexity O(1),Space Complexity O(1) </li>
</ul>

</div>
</div>
<a id="a85866ff9f6a7a76261d735387420b887" name="a85866ff9f6a7a76261d735387420b887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85866ff9f6a7a76261d735387420b887">&#9670;&#160;</a></span>merge() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec014a02a59d54633eb136bb59a70646" name="aec014a02a59d54633eb136bb59a70646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec014a02a59d54633eb136bb59a70646">&#9670;&#160;</a></span>merge() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename compare = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">compare{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ddf695b1f0af76204cb8f362e492450" name="a8ddf695b1f0af76204cb8f362e492450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddf695b1f0af76204cb8f362e492450">&#9670;&#160;</a></span>merge() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f09bf77c228c55bd9587348f8a89c7f" name="a2f09bf77c228c55bd9587348f8a89c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f09bf77c228c55bd9587348f8a89c7f">&#9670;&#160;</a></span>merge() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename compare = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">compare{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6139cf2be37d2129c8b71bd12278e10c" name="a6139cf2be37d2129c8b71bd12278e10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6139cf2be37d2129c8b71bd12278e10c">&#9670;&#160;</a></span>merge() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a> * <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dff547e343bd6ae536ec928504ac625" name="a6dff547e343bd6ae536ec928504ac625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dff547e343bd6ae536ec928504ac625">&#9670;&#160;</a></span>merge() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename compare = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a> * <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structforward__lists_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bc075dd0125e957b5f0a748acd1c0a2" name="a8bc075dd0125e957b5f0a748acd1c0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc075dd0125e957b5f0a748acd1c0a2">&#9670;&#160;</a></span>merge_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b1fdd0820f7812c3230dcb9345f7a29" name="a9b1fdd0820f7812c3230dcb9345f7a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1fdd0820f7812c3230dcb9345f7a29">&#9670;&#160;</a></span>merge_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::merge_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a838660b60ee44d87a9aa4c3061258161" name="a838660b60ee44d87a9aa4c3061258161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838660b60ee44d87a9aa4c3061258161">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a> &amp; <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad69087950f6ae29dd5808aac53e37e94" name="ad69087950f6ae29dd5808aac53e37e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69087950f6ae29dd5808aac53e37e94">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforward__lists.html">forward_lists</a> &amp; <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assignment constructor </p>

</div>
</div>
<a id="ac35b4c372dde1087d1faac0d112be42f" name="ac35b4c372dde1087d1faac0d112be42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35b4c372dde1087d1faac0d112be42f">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pop_back adalah method untuk deletion node di posisi tail </p>
<p>time complexity O(n),Space complexity O(1) </p>

</div>
</div>
<a id="a345e09a8d6da8b0d35e21e2310155776" name="a345e09a8d6da8b0d35e21e2310155776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345e09a8d6da8b0d35e21e2310155776">&#9670;&#160;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method untuk deletion val pada pos front </p>
<p>Time complexity O(1),Space Complexity O(1) </p>

</div>
</div>
<a id="aa684b6f9494a2bc6aea68e6f9c779b0d" name="aa684b6f9494a2bc6aea68e6f9c779b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa684b6f9494a2bc6aea68e6f9c779b0d">&#9670;&#160;</a></span>prepend_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::prepend_range </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70a522c91007772dada1b9f6976db62b" name="a70a522c91007772dada1b9f6976db62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a522c91007772dada1b9f6976db62b">&#9670;&#160;</a></span>print_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::print_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method untuk print semua node list </p>
<p>Time complexity O(n),Space Complexity O(n) </p>

</div>
</div>
<a id="a7dea953d9dccb65c4bf7194ba7cb3f17" name="a7dea953d9dccb65c4bf7194ba7cb3f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dea953d9dccb65c4bf7194ba7cb3f17">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adalah method untuk melakukan insertion dari posisi belakang(tail) </p>
<p>time complexity O(1) </p>

</div>
</div>
<a id="a573d97a5140946da88fc8add02850f83" name="a573d97a5140946da88fc8add02850f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573d97a5140946da88fc8add02850f83">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fad00bbc80dfdbb606fd234616012d0" name="a4fad00bbc80dfdbb606fd234616012d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fad00bbc80dfdbb606fd234616012d0">&#9670;&#160;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d73029a03f0da14ac2d90400aa43597" name="a2d73029a03f0da14ac2d90400aa43597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d73029a03f0da14ac2d90400aa43597">&#9670;&#160;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method untuk insertion val pada pos front </p>
<p>Time complexity O(1),Space Complexity O(1) </p>

</div>
</div>
<a id="a9bb151680f26183d69901a068be5fea2" name="a9bb151680f26183d69901a068be5fea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb151680f26183d69901a068be5fea2">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method overload remove,untuk menghapus node pada posisi pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>posisi node yang ingin dihapus</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity best case: O(1) jika pos di head-&gt;next(node pertama) average case: O(n) jika pos ditengah list worst case: O(n) jika pos diakhir list(tail) </p>

</div>
</div>
<a id="aed969f13634751e244f9d307072dafeb" name="aed969f13634751e244f9d307072dafeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed969f13634751e244f9d307072dafeb">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload remove untuk menghapus node dengan nilai sama dengan parameter value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>nilai node yang ingin dihapus pada list</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity Best case: O(1),jika hanya node dan berada di pos head-&gt;next average case: O(n) worst case: O(n),tetapi menghapus semua node pada list </p>

</div>
</div>
<a id="a8bd7863cc50185b95db693d1ba6fd75d" name="a8bd7863cc50185b95db693d1ba6fd75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd7863cc50185b95db693d1ba6fd75d">&#9670;&#160;</a></span>remove_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::remove_count </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad226ed7b442c787418eba74c5a661d4e" name="ad226ed7b442c787418eba74c5a661d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad226ed7b442c787418eba74c5a661d4e">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPred&gt; <br />
requires (std::predicate&lt;UnaryPred&amp;, const T&amp;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">UnaryPred</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fedd388ecf4ee573e67ec914b2d6f10" name="a4fedd388ecf4ee573e67ec914b2d6f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fedd388ecf4ee573e67ec914b2d6f10">&#9670;&#160;</a></span>remove_if_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPred&gt; <br />
requires (std::predicate&lt;UnaryPred&amp;,const T&amp;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::remove_if_count </td>
          <td>(</td>
          <td class="paramtype">UnaryPred</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4fc2304c3059c1d838b94a73c6110e2" name="ae4fc2304c3059c1d838b94a73c6110e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fc2304c3059c1d838b94a73c6110e2">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resize adalah method untuk mengubah ukuran sebuah list </p>
<ul>
<li>If count is equal to the current size, does nothing.</li>
<li>If the current size is greater than count, the container is reduced to its first count elements.</li>
<li>If the current size is less than count, then: -1) Additional default-inserted elements are appended. -2) Additional copies of value are appended. </li>
</ul>

</div>
</div>
<a id="a4bfc7c2e1150d78b63663a2f7568032d" name="a4bfc7c2e1150d78b63663a2f7568032d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfc7c2e1150d78b63663a2f7568032d">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8531c2829b5ba52d436338be3d50916e" name="a8531c2829b5ba52d436338be3d50916e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8531c2829b5ba52d436338be3d50916e">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f15bca63d3b2ba4d269abab2f94f9b7" name="a2f15bca63d3b2ba4d269abab2f94f9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f15bca63d3b2ba4d269abab2f94f9b7">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa274e7835e1e4020a803783d7ec1dbc3" name="aa274e7835e1e4020a803783d7ec1dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa274e7835e1e4020a803783d7ec1dbc3">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Compare = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75061e69811c122993e15dab0d2521e4" name="a75061e69811c122993e15dab0d2521e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75061e69811c122993e15dab0d2521e4">&#9670;&#160;</a></span>splice_after() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa45fb3ab2dfe2e3ddfd8322f994ed6bc" name="aa45fb3ab2dfe2e3ddfd8322f994ed6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45fb3ab2dfe2e3ddfd8322f994ed6bc">&#9670;&#160;</a></span>splice_after() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9686749a1d12fdb9d4e39cb8fd852ffe" name="a9686749a1d12fdb9d4e39cb8fd852ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9686749a1d12fdb9d4e39cb8fd852ffe">&#9670;&#160;</a></span>splice_after() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>It</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af47f75700dd28948192e16895bb5d7b8" name="af47f75700dd28948192e16895bb5d7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47f75700dd28948192e16895bb5d7b8">&#9670;&#160;</a></span>splice_after() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b8b4f9f90f2f91fa3995fe038e70aaa" name="a4b8b4f9f90f2f91fa3995fe038e70aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8b4f9f90f2f91fa3995fe038e70aaa">&#9670;&#160;</a></span>splice_after() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dfa0841b588e073883f6ce046502986" name="a4dfa0841b588e073883f6ce046502986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfa0841b588e073883f6ce046502986">&#9670;&#160;</a></span>splice_after() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforward__lists_1_1Iterator.html">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>It</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>slice after method untuk memindahkan node dari satu list ke list lain tanpa menyalin data,tetapi move node pointer </p>
<p>Time complexity overloads</p><ul>
<li>void splice_after( const_iterator pos, forward_list&amp; other ) -&gt; O(1)</li>
<li>void splice_after( const_iterator pos, forward_list&amp;&amp; other ) -&gt; O(1)</li>
<li>void splice_after( const_iterator pos, forward_list&amp; other,
        const_iterator it ) -&gt; O(1)</li>
<li>void splice_after( const_iterator pos, forward_list&amp;&amp; other,
        const_iterator it ) -&gt;O(1)</li>
<li>void splice_after( const_iterator pos, forward_list&amp; other,
        const_iterator first, const_iterator last ) -&gt; O(n) </li>
</ul>

</div>
</div>
<a id="ae81c81d81520179d53979e2c2e17b311" name="ae81c81d81520179d53979e2c2e17b311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81c81d81520179d53979e2c2e17b311">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9c9859a30eba9eff0a6c20bcb662093" name="ad9c9859a30eba9eff0a6c20bcb662093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c9859a30eba9eff0a6c20bcb662093">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>others</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42ca065a6ce2d83adb5d20fa72f78530" name="a42ca065a6ce2d83adb5d20fa72f78530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ca065a6ce2d83adb5d20fa72f78530">&#9670;&#160;</a></span>uniqe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::uniqe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7bf2b62a9f566aa71031bb4b7aa82c6" name="ae7bf2b62a9f566aa71031bb4b7aa82c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bf2b62a9f566aa71031bb4b7aa82c6">&#9670;&#160;</a></span>uniqe_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::uniqe_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a40ee44479b2e65bc84c3d402648f788a" name="a40ee44479b2e65bc84c3d402648f788a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ee44479b2e65bc84c3d402648f788a">&#9670;&#160;</a></span>alloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4b8ffb5a9805204d6b06324dd7151990">node_allocator_type</a> <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a867aa7370d5822cc13138bfca6f42238" name="a867aa7370d5822cc13138bfca6f42238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867aa7370d5822cc13138bfca6f42238">&#9670;&#160;</a></span>head</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a>* <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::head = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab47d1cd8e4febd01feae8cb3ea5ad8bc" name="ab47d1cd8e4febd01feae8cb3ea5ad8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47d1cd8e4febd01feae8cb3ea5ad8bc">&#9670;&#160;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a477a4d2a03ec01ffdb339c0d99c0c629" name="a477a4d2a03ec01ffdb339c0d99c0c629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477a4d2a03ec01ffdb339c0d99c0c629">&#9670;&#160;</a></span>tail</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structforward__lists_1_1Node.html">Node</a>* <a class="el" href="classforward__lists.html">forward_lists</a>&lt; T, Allocator &gt;::tail</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>header/<a class="el" href="forward__list_8hpp_source.html">forward_list.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="classforward__lists.html">forward_lists</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
